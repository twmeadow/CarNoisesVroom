import numpy as npfrom scipy.io import wavfileimport matplotlib.pyplot as pltimport sounddevice as sd# --- Load WAV ---sample_rate, dataF = wavfile.read("aero_car_noise.wav")def plotFFT(data):    if data.ndim > 1:        data = data.mean(axis=1)        N = len(data)    fft_vals = np.fft.fft(data)    fft_freqs = np.fft.fftfreq(N, 1/sample_rate)        pos_mask = fft_freqs >= 0    fft_vals = fft_vals[pos_mask]    fft_freqs = fft_freqs[pos_mask]        plt.plot(fft_freqs, np.abs(fft_vals) / np.max(np.abs(fft_vals)))    plt.xlabel("Frequency (Hz)")    plt.ylabel("Magnitude")    plt.xlim(0, 800)    plt.tight_layout()    plt.show()        k = 10    largest = np.partition(np.abs(fft_vals), -k)[-k:]    return largest# üî• Phase accumulator addedphases = Nonedef make_sine_sum(freqs, mags, fs, t):    global phases    freqs = np.array(freqs)    mags  = np.array(mags)    if phases is None:        phases = np.zeros_like(freqs)    dt = 1 / fs    N = len(t)    signal = np.zeros(N)    for idx, (f, m) in enumerate(zip(freqs, mags)):        # generate continuous phase        phase_inc = 2 * np.pi * f * dt        phase_array = phases[idx] + phase_inc * np.arange(N)        signal += m * np.sin(phase_array)        # update stored phase        phases[idx] = phase_array[-1] % (2*np.pi)    return signal# --- Example usage ---fs = 44100duration =1t = np.linspace(0, duration, int(fs * duration), endpoint=False)fl = [175, 250, 380, 410, 320, 20, 80, 100, 120, 200, 150]ml = [.6, 1, .6, .6, .4, .15, .15, .15, .15, .3, .5]signal = make_sine_sum(fl, ml, fs, t)"""# Your logic: raise pitch by increasing sample ratefor i in range(10):    signal = make_sine_sum(fl, ml, fs, t)    # ‚≠ê pitch rising by sample-rate change    fsp = (1 + i/50) * fs    sd.play(signal, fsp)    sd.wait()"""# FFT stuffsd.play(signal)plotFFT(signal)